'''
DP(bottom-up+memoization) 사용

1. n을 구성하는 제곱수들의 개수가 "최소"! 또
이떄 최소의 제곱수 합을 만들기 위해서는 최소의 제곱수 합이 필요하기에
이들을 부분적으로 저장하여 중복계산을 줄이는 DP를 사용하는 것이 좋다.

2. 규칙성:
!(n(타겟) - ?^2(타겟수에 가장 가까운 제곱수)) -?(n-?^2의 dp값(구성하는 제곱수의 개수들))
!에 의해서 나중에 +1을 더함.
'''

n = int(input()) #입력
dp=[]
dp.append(0)# 0
dp.append(1)# 1

for i in range(2,n+1): # dp[n]을 구해내는게 목표임. 이를 위해서 dp[0]~dp[n]을 구해내야 최적의 해를 얻을 수 있음
    minv=1e9 #최초의 min값은 크게 해둬야 초기값지정에 문제가없음
    j=1
    while j**2<=i:# dp에서 타겟값에 가장 근사한 제곱수를 뺀 dp를 구해냄
          minv =min(minv,dp[i-j**2])
          j+=1
    dp.append(minv+1) #1을 더하는 이유: 타겟값 = 뺀값 +~ 에서 뺀 값의 숫자개수가 1임

print(dp[n])

