'''
idea
1. 그때마다 시간 기준에 따라 선택-> greedy
1) 기준 : 시간이 적은 것들 고르기. 조건하에(겹치지 않게)
2) 정렬 :  1. 끝나는 시간, 2. 시작 시간
=> 이런 정렬이 나온 이유: 기준인 "시간이 적은 것"이 즉 "끝나는 시간이 짧은 것(앞에서부터 정렬시)"이고
또 그중에서는 시작 시간을 오름차순으로 정렬해야 그 사이에 시간을 최대한 욱여넣을 수 있게된다.


learn
1. 반복문 요소 복수 이용
#1 2
#2 3
for a,b in t:
    print(a,b)
#(1, 2)
#(2, 3)
for a in t:
    print(a)

2. lambda식을 통해 함수를 간결하게 사용할수 있다
+이걸 통해 기준을  마련할 수 있다. 다중 기준이면 괄호 쓸 것.(순서 맞춰서)

3. 이중리스트도 되긴 한다.

4. 기준을 세울 때 복수의 기준이 가능하다는 점 항상 명심하자.(서순이 있겠지만)

'''

n = int(input())

case = [tuple(map(int,input().split())) for _ in range(n)]

case.sort(key=lambda x:(x[1],x[0]))

result = 0 # 일정수 1개가 있어야 겠지만, last=0으로 지정함으로써 한 번 if를 거쳐 0으로 지정해도 상관 없다.
last = 0 # 0으로 먼저 정해야, 최초로 last가 반복문 내부에서 튜플에 의해 지정되고,
# 또 이렇게 지정된 최초의 튜플에 따른 일정 수 1개가(result+=1) 증가하게 된다.

# 반복문 돌려가며 갱신되어 가는 last(마감시간)에 맞춰 result(일정 수)를 늘려간다
#
for a,b in case:
    if a>=last:
        result+=1
        last = b
print(result)

